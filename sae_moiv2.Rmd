---
title: "SAE_jehanne"
author: "Jehanne Baleydier"
date: "2023-10-14"
output: html_document
---
### ***1 charger les données :***

A changer pour être dans le bon répertoire

```{r, echo=FALSE}
#setwd("~/BUT SD/semestre 3/serie_chronologique/sae/projet/")
```

Charger le jeux de données, nous l'apperlerons "data".

```{r}
#data <- read.csv("route_intersection.csv")
data = read.csv("C:/Users/Cédric/Downloads/route_intersection.csv")
```

Transformer les dates en format date sur R, on ne prendra pas en compte les heures mais seulement les jours. 

```{r}
data$date <- as.Date(data$date)
```

Premier aperçu des données avec un nuage de points : 
```{r}
plot(data$date,data$vehicule)
```

### ***2 Modification du tableau de données ***
Chargement des librairies nécessaires : 
```{r}
library(dplyr)
library(ggplot2)
```

Modification du tableau de données pour avoir un nouveau tableau avec les données par type, intersections, sorties par jour

```{r}
data_modifie <- data %>% mutate(
  I1 = ifelse(intersection == "I1", as.integer(vehicule), NA),
    S1 = ifelse(intersection == "S1", as.integer(vehicule), NA),
    I2 = ifelse(intersection == "I2", as.integer(vehicule), NA),
    S2 = ifelse(intersection == "S2", as.integer(vehicule), NA),
    I3 = ifelse(intersection == "I3", as.integer(vehicule), NA),
    S3 = ifelse(intersection == "S3", as.integer(vehicule), NA),
    I4 = ifelse(intersection == "I4", as.integer(vehicule), NA),
    S4 = ifelse(intersection == "S4", as.integer(vehicule), NA),
    N = ifelse(intersection == "N", as.integer(vehicule), NA)
  ) %>%
  group_by(date) %>%
  summarize(
    I1 = sum(I1, na.rm = TRUE),
    S1 = sum(S1, na.rm = TRUE),
    I2 = sum(I2, na.rm = TRUE),
    S2 = sum(S2, na.rm = TRUE),
    I3 = sum(I3, na.rm = TRUE),
    S3 = sum(S3, na.rm = TRUE),
    I4 = sum(I4, na.rm = TRUE),
    S4 = sum(S4, na.rm = TRUE),
    N = sum(N, na.rm = TRUE)
  ) %>%
  ungroup()

```

Calcul des données d'entrées : 
```{r}
t0=which(data_modifie$date=="2017-01-01")
n <- length(data_modifie$date)
data_modifie$E1<-data_modifie$I1+data_modifie$S2-data_modifie$I2
data_modifie$E2<-data_modifie$I2+data_modifie$S3-data_modifie$I3
data_modifie$E3 <- NA
data_modifie$E3[1:t0-1] <-data_modifie$I3[1:t0-1] - data_modifie$N[1:t0-1]
data_modifie$E3[t0:n] <- data_modifie$I3[t0:n] +data_modifie$S4[t0:n] -data_modifie$I4[t0:n] 
data_modifie$E4 <- NA
data_modifie$E4[t0:n]<-data_modifie$I4[t0:n]-data_modifie$N[t0:n]
#ajout du ratio entrée sur intersection (totale sur j)
data_modifie$E1_I1=data_modifie$E1/data_modifie$I1
data_modifie$E2_I2=data_modifie$E2/data_modifie$I2
data_modifie$E3_I3=data_modifie$E3/data_modifie$I3
data_modifie$E4_I4=data_modifie$E4/data_modifie$I4



ggplot(data=data_modifie,aes(x=date,y=E1_I1))+
  geom_point(color="blue")+
  geom_point(aes(y=E2_I2),color="green")+
  geom_point(aes(y=E3_I3),color="red")+
  geom_point(aes(y=E4_I4),color="purple")

data_modifie2= data_modifie %>%  # grouper par mois 
  mutate(month = format(date, "%Y-%m")) %>%
  group_by(month) %>%
  summarize(
    I1 = sum(I1, na.rm = TRUE),
    S1 = sum(S1, na.rm = TRUE),
    I2 = sum(I2, na.rm = TRUE),
    S2 = sum(S2, na.rm = TRUE),
    I3 = sum(I3, na.rm = TRUE),
    S3 = sum(S3, na.rm = TRUE),
    I4 = sum(I4, na.rm = TRUE),
    S4 = sum(S4, na.rm = TRUE),
    N = sum(N, na.rm = TRUE),
    E1 = sum(E1),
    E2 = sum(E2),
    E3 = sum(E3),
    E4 = sum(E4,na.rm=T)
  )
#ajout des ratios entrée/intersections
data_modifie2$E1_I1=data_modifie2$E1/data_modifie2$I1
data_modifie2$E2_I2=data_modifie2$E2/data_modifie2$I2
data_modifie2$E3_I3=data_modifie2$E3/data_modifie2$I3
data_modifie2$E4_I4=data_modifie2$E4/data_modifie2$I4


ggplot(data=data_modifie2,aes(x=month,y=E1_I1))+
  geom_point(color="blue")+
  geom_point(aes(y=E2_I2),color="green")+
  geom_point(aes(y=E3_I3),color="red")+
  geom_point(aes(y=E4_I4),color="purple")

  
```

Aperçu avec un graphique : 
Graphique pour l'intersection n°1
```{r}
ggplot(data = data_modifie, aes(date,I1)) +
  geom_line(col = "blue")+
  geom_line(aes(y=E1), col="red") +
  geom_line(aes(y = S1), col="green")
```
Intersection n°2
```{r}
ggplot(data = data_modifie, aes(date,I2)) +
  geom_line(col = "blue")+
  geom_line(aes(y=E2), col="red") +
  geom_line(aes(y = S2), col="green")
```
Intersection 3 : 
```{r}
ggplot(data = data_modifie, aes(date,I3)) +
  geom_line(col = "blue")+
  geom_line(aes(y=E3), col="red") +
  geom_line(aes(y = S3), col="green")
```
c'est un peu bizard peut-être que je me suis plantée dans les modifications.

Intersection n°4 : 
```{r}
ggplot(data = data_modifie, aes(date,I4)) +
  geom_line(col = "blue")+
  geom_line(aes(y=E4), col="red") +
  geom_line(aes(y = S4), col="green")
```

### ***Modèle sur E1 dans un premier temps***

```{r}
library(zoo)
k <- 5
res_rollmean <- rollmean(data_modifie$E1,k = 2*k+1)
res_rollmean <- c(rep(NA,k),res_rollmean,rep(NA,k))

```
graphique pour obserber ce résultat : 

```{r}
ggplot(data_modifie,aes(x=date,y=E1)) +
geom_point() +
geom_line(aes(y=res_rollmean),col="red",size=1)
```


```{r}
res_lm_E1 <- lm(data_modifie$E1~data_modifie$date)
plot(res_lm_E1$residuals)
```
On observe que les résidus ne sont pas aléatoirement distribués.
Modèle multiplicatif? on voit une cassure 
ou période ?
en tout cas on remarque bien la cassure


Regardons maintenant en séparant le jeux de données à la date d'ouverture de la 
4e intersection : 

```{r}
t0=which(data_modifie$date=="2017-01-01")
data1 <- data_modifie[1:t0-1,]
data2 <- data_modifie[-(1:t0+1),]
```

Moyenne mobile sur E1 : 

```{r}
k <- 5
res_rollmean <- rollmean(data1$E1,k = 2*k+1)
res_rollmean <- c(rep(NA,k),res_rollmean,rep(NA,k))
```

```{r}
ggplot(data1,aes(x=date,y=E1)) +
geom_point() +
geom_line(aes(y=res_rollmean),col="red",size=1)
```
Modèle linéaire : 
```{r}
res_lm_E1 <- lm(data1$E1~data1$date)
ggplot(data = data1, aes(x = data1$date, y = data1$E1)) +
  geom_point() +
  geom_line(aes(y = res_lm_E1$fitted.values), col = "red")
residus <- res_lm_E1$residuals
plot(residus)
```
et si on regarde le début de la liste pour essayer de voir s'il y a une période: 
```{r}
plot(residus[1:42])
```

```{r}
calcul_saison <- function(serie,p){
  n <- length(serie)
  N <- floor(n/p)
  saison <- rep(NA,p)
  for(i in 1:p){
    saison[i] <- mean(serie[i+(1:N-1)*p],na.rm=T)
  }
  saison <- rep(saison,N)
  return(saison)
}
periode <- calcul_saison(residus, 7)
ggplot(data1,aes(x = data1$date,y = residus))+
  geom_point()+
  geom_line(aes(y=periode), col = "red")
```
Non ce n'est vraiment pas terrible snif ! 

et avec la série de différence : 
```{r}
difference <- diff(data_modifie$E1)
plot(difference)
```
Etalement des données de plus en plus de différence : modèle multiplicatif?

#### Essayons avec E2 pour voir ####

moyenne mobile
```{r}
k <- 5
res_rollmean <- rollmean(data_modifie$E2,k = 2*k+1)
res_rollmean <- c(rep(NA,k),res_rollmean,rep(NA,k))
```

```{r}
ggplot(data_modifie,aes(x=date,y=E2)) +
geom_point() +
geom_line(aes(y=res_rollmean),col="red",size=1)
```
On voit quand même très bien la cassure ici, au premier janvier 2017. Pour vérifier on met en place un test de Chow

```{r}
 library(gap)
 res_chow<- chow.test(data1$E2,data1$date,data2$E2,data2$date)
 res_chow
```
La p-value est largement significative on a donc bien une cassure. 

si on ajuste un modèle linéaire sur chacune des deux parties ?
```{r}
res_lm_E2_1 <- lm(data1$E2~data1$date)
data1$tendance_E2 <- res_lm_E2_1$fitted.values
```

visualisation :
```{r}
ggplot(data = data1, aes(date, E2))+
  geom_point()+
  geom_line(aes(y = tendance_E2), col = "red")
```
Analyse des résidus : 
```{r}
data1$residus_E2 <- res_lm_E2_1$residuals
plot(data1$residus_E2)
```
C'est bien sauf quelques mesures anormales j'ai envie de dire c'est normal qu'il
y en ait un peut !

Bon voyons sur la deuxième partie maintenant
```{r}
res_lm_E2_2 <- lm(data2$E2~data2$date)
data2$tendance_E2 <- res_lm_E2_2$fitted.values
ggplot(data = data2, aes(date, E2))+
  geom_point()+
  geom_line(aes(y = tendance_E2), col = "red")
```
```{r}
data2$residus_E2 <- res_lm_E2_2$residuals
plot(data2$residus_E2)
```
c'est quand même beaucoup moins bien zut on fait comment?

#### Et sur E3 ? ####
Moyenne mobile
```{r}
k <- 5
res_rollmean <- rollmean(data_modifie$E3,k = 2*k+1)
res_rollmean <- c(rep(NA,k),res_rollmean,rep(NA,k))

ggplot(data_modifie,aes(x=date,y=E3)) +
geom_point() +
geom_line(aes(y=res_rollmean),col="red",size=1)
```

Houlà ça ressemble pas à grand chose ! je ne sais vraiment pas quoi faire avec ce E3 ????

#### Regargons E4 ####

moyenne mobile : 
```{r}
k <- 5
res_rollmean <- rollmean(data_modifie$E4,k = 2*k+1)
res_rollmean <- c(rep(NA,k),res_rollmean,rep(NA,k))

ggplot(data_modifie,aes(x=date,y=E4)) +
geom_point() +
geom_line(aes(y=res_rollmean),col="red",size=1)
```
détecter la cassure : 
```{r}
library(gap)
 n<-nrow(data2)
 chow_pvalues<-rep(NA,n)
 for(t0 in 2:(n-2)){
 x1<-matrix(data2$date[1:t0],ncol=1)
 y1<-data2$E4[1:t0]
 x2<-matrix(data2$date[-(1:t0)],ncol=1)
 y2<-as.numeric(data2$E4[-(1:t0)])
 res_chow <-chow.test(y1,x1 , y2,x2)
 chow_pvalues[t0]<-res_chow[4]
 }
 #plot(log(chow_pvalues))
 which.min(log(chow_pvalues))
```


#### Proportions ####

J'ai eu l'idée de faire une proportion de E1/I1 parce que s'il y a une augmentation du nombre de passages dans toutes les intersections peut-être qu'en faisant une proportion on peut mieux observer...

```{r}
t0 <- which(data_modifie$date=="2017-01-01")
data_modifie$E1_I1 <- data_modifie$E1/data_modifie$I1
ggplot(data = data_modifie, aes(date, E1_I1))+
  geom_point()+
  geom_line(aes(x=data_modifie$date[t0]), col = "red")+
  geom_line(aes(x=data_modifie$date[t0+38]), col = "blue")
```
ça correspond bien à quelques jours après la cassure on a une baisse !

Ici j'essaye de voir ce qui se passe sur les entrées 1 à 3 de manière globale ainsi qu'au niveau du rapport entré/présent intersection

```{r}
data_modifie

#groupement globale 
data_modifie$E=data_modifie$E1 + data_modifie$E2 + data_modifie$E3
data_modifie$I = data_modifie$I1 + data_modifie$I2 + data_modifie$I3
data_modifie$E_I=data_modifie$E/data_modifie$I

ggplot(data=data_modifie,aes(y=E,x=date))+
  geom_point()

ggplot(data = data_modifie, aes(x = date, y = E_I)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)


#trouver meilleurs modèles

#lineaire globale augmentation
#périodicité selon jour de la semaine peut etre

E_linear=lm(E~date,data=data_modifie)
E_detendance= data_modifie$E -  E_linear$fitted 
data_modifie$E_detendance=E_detendance

ggplot(data=data_modifie,aes(y=E_detendance,x=data_modifie$date))+
  geom_point()+
  geom_smooth(method="lm",color="green")



calcul_periodicite <- function(serie,p){
n <- length(serie)
N <- floor(n/p)
periode <- rep(NA,p)
for(i in 1:p){
periode[i] <- mean(serie[i+(1:(N+1)-1)*p],na.rm=T)
}
if(n == N*p) periode <- rep(periode,N)
if(n > N*p) periode <- c(rep(periode,N),periode[1:(n-(N*p))])
return(periode)
}
data_modifie$E_periode_7j=calcul_periodicite(data_modifie$E_detendance,7)

data_modifie$E_modeleadditif=E_linear$fitted+data_modifie$E_periode_7j

ggplot(data=data_modifie,aes(x=date,y=E))+
  geom_point()+
  geom_line(aes(y=E_modeleadditif),color="blue")+
  scale_x_date(limits = as.Date(c("2016-01-01", "2016-03-31")))


ggplot(data=data_modifie,aes(x=date,y=E))+
  geom_point()+
  geom_line(aes(y=E_modeleadditif),color="blue")

ggplot(data = data_modifie, aes(x = date, y = E)) +
  geom_point() +
  geom_line(aes(y = E_modeleadditif), color = "blue") +
  coord_cartesian(ylim = c(450, 2300),xlim=as.Date(c("2016-01-01", "2016-08-01"))) +
  theme_minimal() +
  labs(title = "Données E et Modèle Additif") +
  labs(x = "Date", y = "Entré") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#data_modifie$E_modelemult=E_linear$fitted*data_modifie$E_periode_7j inadapté


```

meilleur modèle : additif

=> serie des différences
```{r}

data_modifie$E

data_modifie$E_diff=c(NA,diff(data_modifie$E))

ggplot(data = data_modifie,aes(y=E_diff,x=date))+
  geom_point()

```
aggregé les données par semaine pour avoir un jeux de données moins chaotique

```{r}
nrow(data_modifie)/7
data7=data.frame()
groupes = rep(1:ceiling(nrow(data_modifie) / 7), each = 7, length.out = nrow(data_modifie))
groupes
data7=aggregate(. ~ groupes, data = data_modifie, FUN = sum)
data7

ggplot(data=data7,aes(x=1:nrow(data7),y=E))+
  geom_point()
```

analyser les données selon les heures d'influences, aux heures avec le plus de circulation,
la situation s'est elle améliorée.




